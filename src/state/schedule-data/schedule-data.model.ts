/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. */
import * as _ from "lodash";
import { MonthHelper, NUMBER_OF_DAYS_IN_WEEK } from "../../helpers/month.helper";
import { MonthDataArray } from "../../helpers/month-data-array.model";
import { ScheduleKey } from "../../logic/data-access/persistance-store.model";
import {
  FoundationInfoModel,
  validateFoundationInfo,
} from "./foundation-info/foundation-info.model";
import { MonthInfoModel, validateScheduleInfo } from "./month-info/month-info.model";
import { ShiftCode, ShiftTypesDict } from "./shifts-types/shift-types.model";
import { validateEmployeeInfo, WorkersInfoModel } from "./worker-info/worker-info.model";
import { validateWorkerShiftsModel, WorkerShiftsModel } from "./workers-shifts/worker-shifts.model";

export enum ScheduleContainerType {
  "MONTH_DM" = "MONTH_DM",
  "SCHEDULE_DM" = "SCHEDULE_DM",
}

export type ScheduleContainerLength = {
  [key in ScheduleContainerType]: number[];
};

const POSSIBLE_WEEK_COUNT_IN_MONTH = [4, 5, 6];

export const SCHEDULE_CONTAINERS_LENGTH: ScheduleContainerLength = {
  MONTH_DM: [28, 29, 30, 31],
  SCHEDULE_DM: POSSIBLE_WEEK_COUNT_IN_MONTH.map((wc) => wc * NUMBER_OF_DAYS_IN_WEEK),
};

export interface ScheduleDataModel {
  schedule_info: MonthInfoModel;
  month_info: FoundationInfoModel;
  employee_info: WorkersInfoModel;
  shifts: WorkerShiftsModel;
  shift_types: ShiftTypesDict;
  isAutoGenerated: boolean;
  isCorrupted: boolean;
}

/**
 * Creates new type with data for concrete month
 */
type MonthModel<TOriginal> = {
  [key in keyof TOriginal]: TOriginal[key] extends unknown[]
    ? MonthDataArray<TOriginal[key][0]>
    : TOriginal[key];
};
export type MonthWorkerShiftsModel = MonthModel<ScheduleDataModel["shifts"]>;
export type MonthFoundationInfoModel = MonthModel<ScheduleDataModel["month_info"]>;

export interface MonthDataModel
  extends Omit<ScheduleDataModel, "schedule_info" | "revisionType" | "month_info" | "shifts"> {
  scheduleKey: ScheduleKey;
  shifts: MonthWorkerShiftsModel;
  month_info: MonthFoundationInfoModel;
}

export function validateScheduleDM({
  shifts,
  month_info: monthInfo,
  employee_info: employeeInfo,
  shift_types: shiftTypes,
  schedule_info: scheduleInfo,
}: ScheduleDataModel): void {
  validateScheduleInfo(scheduleInfo);
  validateWorkerShiftsModel(shifts, ScheduleContainerType.SCHEDULE_DM);
  validateFoundationInfo(monthInfo, ScheduleContainerType.SCHEDULE_DM);
  validateEmployeeInfo(employeeInfo);
  validateScheduleContainerDataIntegrity({
    shifts,
    month_info: monthInfo,
    employee_info: employeeInfo,
    shift_types: shiftTypes,
  });
}

export function validateMonthDM({
  shifts,
  month_info: monthInfo,
  employee_info: employeeInfo,
  shift_types: shiftTypes,
}: MonthDataModel): void {
  validateWorkerShiftsModel(shifts, ScheduleContainerType.MONTH_DM);
  validateFoundationInfo(monthInfo, ScheduleContainerType.MONTH_DM);
  validateEmployeeInfo(employeeInfo);
  validateScheduleContainerDataIntegrity({
    shifts,
    month_info: monthInfo,
    employee_info: employeeInfo,
    shift_types: shiftTypes,
  });
}

export function isMonthModelEmpty(monthDataModel: MonthDataModel): boolean {
  const requiredFields: (keyof Pick<
    MonthDataModel,
    "employee_info" | "month_info" | "shifts"
  >)[] = ["employee_info", "month_info", "shifts"];
  return requiredFields.every((field) => {
    const requiredObject = monthDataModel[field];
    return Object.values(requiredObject).every((field) => _.isEmpty(field));
  });
}

const createMonthArray = <T>(monthLen: number, getValue: () => T): MonthDataArray<T> =>
  new Array(monthLen).fill(getValue()) as MonthDataArray<T>;

export function createEmptyMonthDataModel(
  scheduleKey: ScheduleKey,
  {
    employee_info,
    shifts,
    shift_types,
  }: Pick<MonthDataModel, "employee_info" | "shifts" | "shift_types">
): MonthDataModel {
  const dates = MonthHelper.daysInMonth(scheduleKey.month, scheduleKey.year);
  const monthLength = dates.length;

  const freeShifts: MonthWorkerShiftsModel = {};
  Object.keys(shifts).forEach((key) => {
    freeShifts[key] = createMonthArray(monthLength, () => ShiftCode.W);
  });

  const monthDataModel: MonthDataModel = {
    scheduleKey,
    month_info: {
      children_number: createMonthArray(monthLength, () => 0),
      extra_workers: createMonthArray(monthLength, () => 0),
      frozen_shifts: createMonthArray(0, () => undefined),
      dates: dates as MonthDataArray<number>,
    },
    employee_info: _.cloneDeep(employee_info),
    shifts: freeShifts,
    isAutoGenerated: true,
    shift_types: _.cloneDeep(shift_types),
    isCorrupted: false,
  };

  validateMonthDM(monthDataModel);
  return monthDataModel;
}

export function getScheduleKey(newSchedule: ScheduleDataModel): ScheduleKey {
  return new ScheduleKey(
    newSchedule.schedule_info.month_number ?? new Date().getMonth(),
    newSchedule.schedule_info.year ?? new Date().getFullYear()
  );
}

type KeysForContainerDataIntegrityValidation =
  | "month_info"
  | "employee_info"
  | "shifts"
  | "shift_types";
function validateScheduleContainerDataIntegrity<
  TContainer extends ScheduleDataModel | MonthDataModel
>({
  month_info: monthInfo,
  employee_info: employeeInfo,
  shifts,
  shift_types: shiftTypes,
}: Pick<TContainer, KeysForContainerDataIntegrityValidation>): void {
  const scheduleLen = monthInfo.dates.length;
  validateShiftLengthIntegrity(scheduleLen, shifts);
  validateWorkersIntegrity(employeeInfo, shifts);
  ensureShiftTypesIntegrity(shiftTypes, shifts);
}

function validateShiftLengthIntegrity(
  scheduleLen: number,
  shifts: WorkerShiftsModel | MonthWorkerShiftsModel
): void {
  if (shifts !== undefined && !_.isEmpty(shifts)) {
    const [worker, workerShifts] = Object.entries(shifts)[0];
    const shiftLen = workerShifts.length;
    if (shiftLen !== scheduleLen) {
      throw new Error(
        `Shifts for worker: ${worker} have different length ${shiftLen} than dates ${shiftLen} `
      );
    }
  }
}

function validateWorkersIntegrity(
  employeeInfo: WorkersInfoModel,
  shifts: WorkerShiftsModel | MonthWorkerShiftsModel
): void {
  const workersWithShifts = _.sortBy(Object.keys(shifts));
  const workersWithType = _.sortBy(Object.keys(employeeInfo.type));
  if (!_.isEqual(workersWithType, workersWithShifts)) {
    throw new Error(
      `Shifts cannot be defined for workers without defined type. Workers without defined shifts are
      ${workersWithType.filter((w) => !workersWithShifts.includes(w)).join(", ")}`
    );
  }
}

function ensureShiftTypesIntegrity(
  shiftModel: ShiftTypesDict,
  shifts: WorkerShiftsModel | MonthWorkerShiftsModel
): void {
  const shiftTypes = Object.keys(shiftModel);

  Object.keys(shifts).forEach((worker) => {
    shifts[worker] = shifts[worker].map((shiftCode) =>
      !shiftTypes.includes(shiftCode) ? ShiftCode.W : shiftCode
    );
  });
}
